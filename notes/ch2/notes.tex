\documentclass[letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage[shortlabels]{enumitem}
\usepackage{amsthm}
\usepackage[margin=1in]{geometry}
\usepackage{tikz-cd}
\usepackage{mathabx}
\usepackage{dsfont}
\usepackage{relsize}
\usepackage{xifthen}
\usepackage{extarrows}
\usepackage{pifont}
\usepackage{mathtools}
\usepackage{xspace}
\usepackage{bussproofs}
\usepackage{flagderiv}

\renewcommand{\introsymb}{\!}

\newenvironment{theorem}[2][]{\par\medskip
	\noindent \textbf{Theorem~#2}~~~#1 \rmfamily\em}{\medskip}

\newenvironment{lemma}[2][]{\par\medskip
	\noindent \textbf{Lemma~#2}~~~#1 \rmfamily\em}{\medskip}

\newenvironment{corollary}[2][]{\par\medskip
	\noindent \textbf{Corollary~#2}~~~#1 \rmfamily\em}{\medskip}

\newenvironment{remark}[2][]{\par\medskip
	\noindent \textbf{Remark~#2}~~~#1 \rmfamily\em}{\medskip}

\newenvironment{remarkNonNum}[1][]{\par\medskip
	\noindent \textbf{Remark}~~~#1 \rmfamily\em}{\medskip}
	
\newenvironment{notation}[2][]{\par\medskip
	\noindent \textbf{Notation~#2}~~~#1 \rmfamily\em}{\medskip}

\newenvironment{convention}[2][]{\par\medskip
	\noindent \textbf{Convention~#2}~~~#1 \rmfamily\em}{\medskip}
	
\newenvironment{examplesNonNum}[1][]{\par\medskip
	\noindent \textbf{Examples}~~~#1 \rmfamily}{\medskip}

\newenvironment{definition}[2][]{\par\medskip
	\noindent \textbf{Definition~#2}~~~#1 \rmfamily}{\medskip}

\usetikzlibrary{decorations.markings,positioning}

\newcommand{\iso}{\cong}

\newcommand{\Z}{\mathbb{Z}}
\renewcommand{\S}{\GenericError{}}

\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\renewcommand{\l}{\lambda}
\newcommand{\aeq}{=_\alpha}
\newcommand{\beq}{=_\beta}
\newcommand{\nbeq}{\neq_\beta}
\newcommand{\naeq}{\neq_\alpha}
\newcommand{\bnf}{$\beta$-nf\xspace}

\newcommand{\betaro}{\rightarrow_\beta}
\newcommand{\betar}{\twoheadrightarrow_\beta}

\newcommand{\larr}{\lambda \!\! \rightarrow}


\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
    \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

\DeclareMathOperator{\Ima}{Im}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Sub}{Sub}
\DeclareMathOperator{\pr}{pr}
\DeclareMathOperator{\fact}{fact}
\DeclareMathOperator{\ifT}{if}
\DeclareMathOperator{\iszero}{iszero}
\DeclareMathOperator{\then}{then}
\DeclareMathOperator{\elseT}{else}
\DeclareMathOperator{\mult}{mult}
\DeclareMathOperator{\pred}{pred}

\newcommand{\T}{\mathbb{T}}
\newcommand{\V}{\mathbb{V}}

\newcommand{\arr}[1][]{%
	\ifthenelse{\isempty{#1}}{\longrightarrow}{\xlongrightarrow{#1}}%
}

\newcommand{\hookarr}[1][]{%
	\ifthenelse{\isempty{#1}}{\longhookrightarrow}{\lhook\joinrel\xrightarrow{#1}}%
}


\author{Notes by Donald Pinckney}
\title{Notes from: Type Theory and Formal Proof, Chapter 2: Simply Typed Lambda Calculus, $\larr$}

\begin{document}
\maketitle

Untyped lambda calculus offers a concise and elegant formal system for expressing the behavior of functions. However, it is a bit ``too liberal'' with what it allows as terms, giving rise to some rather non-intuitive constructions. The goal is now to add types so as to prevent these strange constructions. In this chapter we add \emph{simple types} which will actually be a bit too restrictive, and then in later chapters we will add more sophisticated types.

\section{Simple Types}

We define the set of \emph{simple types} $\T$ by a grammar. Let $\V = \{\alpha, \beta, \gamma, \cdots \}$ be an infinite set of \emph{type variables}. Note that from here on \emph{variable} refers to ordinary variables $x, y, z, \cdots$. while \emph{type variable} refers to $\V$.

\begin{definition}[(Set $\T$ of simple types)]{2.2.1}
	\begin{enumerate}
		\item (Type variable) If $\alpha \in \V$ then $\alpha \in \T$.
		\item (Arrow type) If $\sigma, \tau \in \T$, then $(\sigma \to \tau) \in \T$.
	\end{enumerate}
As an abstract syntax, $\T = \V \mid \T \to \T$.
\end{definition}

\begin{notation}{2.2.2}
	\begin{enumerate}
		\item We use $\alpha, \beta, \cdots$ for type variables.
		\item We use $\sigma, \tau, \cdots$ (occasionally $A, B, \cdots$) for arbitrary simple types.
		\item Arrow types are right associative.
	\end{enumerate}
\end{notation}

Examples include $\gamma, \beta \to \gamma, (\gamma \to \alpha) \to \alpha \to \beta \to \gamma$, etc. The intended intuitive meaning of simple types is that type variables are abstract representations of basic types such as nat, bool, etc. Arrow types represent function types.

\section{Derivation Rules}

We now want to decorate our $\l$-terms with types. We revise the syntax of $\l$-terms by indicating explicitly the types of binding variables:
\begin{definition}[(Pre-typed $\l$-terms, $\Lambda_\T$)]{2.4.1}
	\[
		\Lambda_\T = V \mid (\Lambda_\T \Lambda_\T) \mid (\l V : \T . \Lambda_\T)
	\]
\end{definition}

To express things like ``$\l$-term $M$ has type $\sigma$'' in a context $\Gamma$, we define a \emph{judgment}:

\begin{definition}[(Statement, declaration, context, judgment)]{2.4.2}
	\begin{enumerate}
		\item A \emph{statement} is of the form $M : \sigma$, where $M \in \Lambda_\T$ and $\sigma \in \T$. In such a statement $M$ is called the \emph{subject} and $\sigma$ is called the \emph{type}.
		\item A \emph{declaration} is a statement with subject being some \emph{variable}.
		\item A \emph{context} is a list of declarations with \emph{different subjects each}.
		\item A \emph{judgment} has the form $\Gamma \vdash M : \sigma$, with $\Gamma$ a context and $M : \sigma$ a statement. We say that such a judgment is \emph{derivable} if $M$ has type $\sigma$ in context $\Gamma$.
	\end{enumerate}
\end{definition}

Note that we consider the variables declared in a context to be binding variables. Next we have the derivation rules for $\larr$:

\begin{definition}[(Derivation rules for $\larr$)]{2.4.5}
	\begin{enumerate}
		\item (var) $\Gamma \vdash x : \sigma$ if $x : \sigma \in \Gamma$
		\item (appl) \AxiomC{$\Gamma \vdash M : \sigma \to \tau$}\AxiomC{$\Gamma \vdash N : \sigma$}\BinaryInfC{$\Gamma \vdash M N : \tau$}\DisplayProof
		\item (abst) \AxiomC{$\Gamma, x : \sigma \vdash M : \tau$}\UnaryInfC{$\Gamma \vdash \l x : \sigma . M : \sigma \to \tau$}\DisplayProof
	\end{enumerate}
\end{definition}

\begin{remarkNonNum}
	There is a correspondence between (appl) and (abst) rules defined above and implication elimination (modus ponens) and introduction in logic. See book, page 43 for more details.
\end{remarkNonNum}

\begin{definition}[(Legal $\larr$ terms)]{2.4.10}
	A pre-typed term $M$ in $\larr$ is \emph{legal} if there exist context $\Gamma$ and type $\rho$ such that $\Gamma \vdash M : \rho$.
\end{definition}

\begin{examplesNonNum}
	The term $x x$ is not legal. In order for $x x$ to have a type, it must be through the application rule, so it must be that $x : \sigma \to \tau$ for some $\sigma$ and $\tau$ (via the left $x$). However, in order to use the application rule we must also have that $x : \sigma$ (via the right $x$). Therefore, in order to have $\Gamma \vdash x x : \rho$ we must have that $x : \sigma \in \Gamma$ and $x : \sigma \to \tau \in \Gamma$. But this violates the definition of a context.
\end{examplesNonNum}

\section{Flag Format of Proofs}

A standard way of writing proofs inside a derivation system such as Definition 2.4.5 is in a tree-style. However, this quickly becomes unwieldy with larger proofs. Instead, we use the \emph{flag format} of derivations. One displays each \emph{declaration} (i.e. element of the context) in a ``flag'', with the ``flag pole'' indicating for what portion of the proof the declaration is in the context. In some situations we also omit uses of the (var) rule from the written proof, though they are still part of the proof.

\begin{examplesNonNum}
	Consider the following tree-style proof:
\begin{prooftree}
	\AxiomC{$y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
	\AxiomC{$y : \alpha \to \beta, z : \alpha \vdash z : \alpha$}
	\BinaryInfC{$y : \alpha \to \beta, z : \alpha \vdash yz : \beta$}
	\UnaryInfC{$y : \alpha \to \beta \vdash \l z : \alpha . y z : \alpha \to \beta$}
	\UnaryInfC{$\emptyset \vdash \l y : \alpha \to \beta . \l z : \alpha . y z : (\alpha \to \beta) \to \alpha \to \beta$}
\end{prooftree}

If we rewrite this proof in flag-style and including uses of (var) rule, we get:

\begin{flagderiv}
	\introduce*{$(a)$}{y : \alpha \to \beta}{}
		\introduce*{$(b)$}{z : \alpha}{}
			\step*{$(1)$}{y : \alpha \to \beta}{(var) on $(a)$}
			\step*{$(2)$}{z : \alpha}{(var) on $(b)$}
			\step*{$(3)$}{yz: \beta}{(appl) on $(1)$ and $(2)$}
		\conclude*{$(4)$}{\l z : \alpha . y z : \alpha \to \beta}{(abst) on $(3)$}
	\conclude*{$(5)$}{\l y : \alpha \to \beta . \l z : \alpha . y z : (\alpha \to \beta) \to \alpha \to \beta}{(abst) on $(4)$}
\end{flagderiv}

If we choose to exclude uses of (var) we would write:

\begin{flagderiv}
	\introduce*{$(a)$}{y : \alpha \to \beta}{}
	\introduce*{$(b)$}{z : \alpha}{}
	\step*{$(1')$}{yz: \beta}{(appl) on $(a)$ and $(b)$}
	\conclude*{$(2')$}{\l z : \alpha . y z : \alpha \to \beta}{(abst) on $(1')$}
	\conclude*{$(3')$}{\l y : \alpha \to \beta . \l z : \alpha . y z : (\alpha \to \beta) \to \alpha \to \beta}{(abst) on $(2')$}
\end{flagderiv}

\end{examplesNonNum}

\section{Kinds of problems in type theory}

In general there are 3 kinds of problems to be solved in type theory:

\begin{enumerate}
	\item \emph{Well-typedness / typeability}.
	
	In this problem, we are given a term $M$ and wish to find an appropriate context and type:
	\[
		? \vdash M : \; ?
	\]
	In other words, show that $M$ is legal. If the term is not legal, then explain where it goes wrong. A variant of this is \emph{type assignment} where a context $\Gamma$ is given, and want to find an appropriate type: $\Gamma \vdash M : \; ?$.

	\item \emph{Type Checking}.
	
	Here, the context $\Gamma$, term $M$, and type $\sigma$ are all given to us, but we want to check (verify) if $\Gamma \overset{?}{\vdash} M : \sigma$.

	\item \emph{Term Finding / Term Construction / Inhabitation}.
	
	In this situation a context $\Gamma$ and type $\sigma$ are given, and we want to determine if there exists a term of that type, given the context: $\Gamma \vdash \; ? : \sigma$. A common specific case is for $\Gamma = \emptyset$.
\end{enumerate}
I recommend looking at sections 2.7, 2.8 and 2.9 in the textbook for guided examples of all 3 of these problems.

\section{General properties of $\larr$}

%In $\larr$ all 3 of the above problems are \emph{decidable}. However, in more advanced systems (in later chapters) Term Finding will not be decidable.


%\section{Well-typedness in $\larr$} \label{welltype}

%\section{Type Checking in $\larr$} \label{typecheck}

%\section{Term Finding in $\larr$} \label{termfind}

%We use these types by adding \emph{statements} (or \emph{typing statements}) of the form $M : \sigma$ to our formal language, to indicate that term $M$ has type $\sigma$. In addition, we assume that for each type $\sigma$ there is an infinitude of variables with type $\sigma$. In addition, each variable $x$ has a \emph{unique} type: if $x : \sigma$ and $x : \tau$ then $\sigma \equiv \tau$.





\end{document}